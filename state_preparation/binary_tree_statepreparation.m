function [circuit, info] = binary_tree_statepreparation(state, logging, circuit_sim)
% quantum circuit for state-preparation
    N = length(state) ;
    n = log(length(state))./log(2) ;
    assert( int32(N) == int32(pow2(n)) ) ;
    state = state ./ norm(state) ;
    if nargin <= 1
        logging = false ; 
        circuit_sim = false ;
    end

    % info struct
    if logging
        info = struct() ;
        nCNOT = 0 ; nRY = 0 ;
    else
        info = false ;
    end

    % original angles
    if isreal(state)
        Varphi = AngleCompute('RY', state, true);    % Varphi for rotation-Y
    else
        state_norm = abs(state);
        state_phase = angle(state);
        Varphi = AngleCompute('RY', state_norm);    % Varphi for rotation-Y
        HatTheta = AngleCompute('RZ', state_phase); % HatTheta for rotation-Z
        if logging, nRZ = 0;end
    end
    
    % transformed angles
    if ~isreal(state), HatTheta(1:N) = HatTheta([2:N,1]); end
    % put the gloabl phase in the end  
    for i = 2:n
        row = pow2(i-1):pow2(i)-1;
        Varphi(row) = UniformlyRotationAngle(Varphi(row));
        if ~isreal(state)
            HatTheta(row) = UniformlyRotationAngle(HatTheta(row));
        end
    end


    circuit = qclab.QCircuit(n) ; 
    if ~isreal(state)
        circuit.push_back(qclab.qgates.RotationZ(0,HatTheta(N))) ; 
    end
    circuit.push_back(qclab.qgates.RotationY(0,Varphi(1))) ; 
    for k = 1 : n-1 
        para_row_index = pow2(k):pow2(k+1)-1 ;
        [circuit, info ] = UniformRotation2( circuit, 'RY', Varphi(para_row_index)', setdiff(0:n-1,k), k, logging, circuit_sim) ; 
        if logging
            nRY = nRY + info_subcircuit.nG ; 
            nCNOT = nCNOT + info_subcircuit.nCNOT ; 
        end
    end
    if ~isreal(state)
        circuit.push_back(qclab.qgates.RotationZ(0,HatTheta(1))) ; 
        if logging, nRZ = nRZ + 1 ; end
        for k = 1 : n-1 
            para_row_index = pow2(k):pow2(k+1)-1 ;
            [circuit, info ] = UniformRotation2( circuit, 'RZ', HatTheta(para_row_index)', setdiff(0:n-1,k), k, logging, circuit_sim) ; 
            if logging
                nRZ = nRZ + info_subcircuit.nG ; 
                nCNOT = nCNOT + info_subcircuit.nCNOT ; 
            end
        end
    end
    if logging
        info.circ.nCNOT = nCNOT ;
        info.circ.nRY = nRY ;
        if ~isreal(state)
            info.circ.nRZ = nRZ ;
        end
    else
        info = false;
    end
end






%% function of angles

function [thetat] = UniformlyRotationAngle(theta)
% Compute the uniformly controlled rotation
% thetat = (M^n)^(-1)*theta
    thetat = grayPermutation( sfwht( theta ) ) ;
end % end of UniformlyRotationAngle

function [ b ] = grayPermutation( a )
  k = log2( size(a, 1) ) ; 
  b = zeros( 2^k, 1 );
  for i = 0 : 2^k - 1
    b( i + 1 ) = a( grayCode( i ) + 1 );
  end
end % end of grayPermutation

function [ a ] = sfwht( a )
% Scaled fast Walsh-Hadamard transform
  k = log2(size(a, 1) ) ;
  for h = 1:k
    for i = 1:2^h:2^k
      for j = i:i+2^(h-1)-1
        x = a( j );
        y = a( j + 2^(h-1) );
        a( j ) = ( x + y ) / 2 ;
        a( j + 2^(h-1) ) = ( x - y ) / 2 ;
      end
    end
  end
end % end of sfwht


function x = grayCode(x)
    x = bitxor(x,bitshift(x,-1));
end



%% function of circuit 

function [ circuit, info, parity_check ] = UniformRotation2( circuit, ctrl_type, para_seq, ctrl_index, targ_index, logging, circuit_sim )
% Input:    circuit     --  generated by qclab.QCircuit; 
%           ctrl_type   --  'RY' for Rotation-Y/ 'RZ' for Rotation-Z 
%           para_seq    --  parameter generated by Walsh-Hadamard transform 
%           ctrl_index  --  a vector contain the control 
%           logging     --  true/false, if true info will log information about compression 
% Output:   circuit     --  QCLAB circuit that block encodes A    
%           info        --  struct containing some info on compression algorithm and circuit

    n_count = log(size(para_seq, 2)) / log(2) ;
    if strcmp( ctrl_type, 'RY' )
        G = @qclab.qgates.RotationY ;
    elseif strcmp( ctrl_type, 'RZ' )
        G = @qclab.qgates.RotationZ ;
    end
    
    nG = 0 ; nCNOT = 0 ;
    i = 1;
    parity_check = int32(0);
    while i <= pow2(n_count)
        if any(para_seq(i) ~= 0)
            % Add CNOTs based on parity_check
            [ circuit, num_CNOT ] = make_CNOT(circuit, parity_check, ctrl_index, targ_index, circuit_sim ) ; 
            nCNOT = nCNOT + num_CNOT ; 

            if circuit_sim
                circuit.push_back( G(targ_index, para_seq(i)) ) ;
            end
            nG = nG + 1 ;
            ctrl = ctrl_pos( i, n_count ) ;
            % update parity check
            parity_check = bitset( int32(0), ctrl_index(ctrl) + 1, int32(1) ) ;
            i = i + 1;
        else
            % update parity check
            while i <= pow2(n_count) && all( para_seq(:,i) == 0 )
                ctrl = ctrl_pos(i, n_count);
                if bitget( parity_check, ctrl_index(ctrl) + 1 ) 
                    parity_check = bitset( parity_check, ctrl_index(ctrl) + 1, int32(0) ) ;
                else
                    parity_check = bitset( parity_check, ctrl_index(ctrl) + 1, int32(1) ) ;
                end
                i = i + 1;
            end
        end
    end
    % Add CNOTs based on parity_check in the final
    [ circuit, num_CNOT ] = make_CNOT(circuit, parity_check, ctrl_index, targ_index, circuit_sim ) ; 
    nCNOT = nCNOT + num_CNOT ; 
    if logging
        info = struct() ;
        info.nG = nG ;
        info.nCNOT = nCNOT ;
    else
        info = false ;
    end
end % end of UniformRotation2

function ctrl = ctrl_pos(i, n)
    ctrl = n - log2(bitxor(grayCode(i-1),grayCode(i))) ;
    if i == pow2(n)
        ctrl = 1;
    end
end

function [ circuit, nCNOT ] = make_CNOT(circuit, parity_check, ctrl_index, targ_index, circuit_sim )
% Add CNOTs based on parity_check in the final
    if nargin <= 3
        targ_index = 0 ;
    end
    nCNOT = 0 ; 
    if parity_check ~= int32(0)
        for j = 1 : numel(ctrl_index)
            if bitget( parity_check, ctrl_index(j) + 1 )
                if circuit_sim
                    circuit.push_back( qclab.qgates.CNOT( ctrl_index(j), targ_index ) ) ;
                end
                nCNOT = nCNOT + 1 ;
            end
        end
    end
end % end of make_CNOT 
